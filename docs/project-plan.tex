\documentclass[a4paper, 10pt]{article}
% \usepackage[left=0.5in, right=0.5in, top=1in, bottom=1in]{geometry}
\usepackage[bookmarksopen=true, hidelinks]{hyperref}
\usepackage{bookmark}
\bookmarksetup{numbered}
\hypersetup{colorlinks, linkcolor={black}}
\usepackage{cite}
\usepackage{listings}
\usepackage{xcolor}
\usepackage{sourcecodepro}

\title{Computing \& Data Analytics Project Plan}
\author{Chan Kwan Yin (3035466978)}
\date{26 September 2020}

\definecolor{back}{rgb}{0.95,0.95,0.92}
\lstdefinestyle{j}{
	backgroundcolor=\color{back},
	keywordstyle=\color{magenta},
	basicstyle=\ttfamily\footnotesize,
	tabsize=4,
}

\begin{document}
\maketitle

\tableofcontents

\section{Background}
\subsection{Trusted Execution Environment}
With the increasing adoption of third-party public cloud services
such as AWS \cite{aws} and Microsoft Azure \cite{azure},
sensitive data often need to be processed on potentially untrusted remote hardware.
This has opened access of such sensitive data
to adversaries with privileged execution rights on the host
through modified hardware, malicious kernel code or just a privilege-escalated process,
by directly reading the internal memory of another process
\cite{ReadProcessMemory} \cite{linuxprocmem}.

Modern CPUs provide features to protect data-handling applications at hardware level,
namely "Trusted Execution Environment" (TEE),
isolating part of an executing process to a partition
which is protected from being accessed from beyond the TEE,
including code from the same process and from the operating system.
\cite{AtamliReinehAhmad2017Affa}.

\subsection{Software Guard Extension}
Intel's Software Guard eXtension (SGX) technology
is an instance of TEE.
It allows creation of TEEs called "enclaves" instantiated by user-level code
such that only components handling sensitive data are executed in enclaves
\cite{AtamliReinehAhmad2017Affa}.

The enclave memory resides in Enclave Page Cache (EPC)
with only approximately 100 MB usable by application code,
the overflow of which leads to "1,000X slowdown compared to regular OS paging" \cite{uranus}.
This implies the existence of a performance-security tradeoff,
where higher enclave use leads to higher protected memory usage,
hence higher risk of memory overflow conditions.
Hence, a minimal enclave partition should be selected
to maximize utilization of the EPC while avoiding SGX memory paging.

\subsection{SGX in JVM}
The benefits of TEEs align with data mining applications
that have become more prevalent in the past decade.
A significant subset of such applications are written
using languages that execute on the Java Virtual Machine (JVM),
such as Hadoop \cite{apachehadoop} and Spark \cite{apachespark}.
More recently, tools have been developed to utilize SGX at the JVM user level,
such as Uranus \cite{uranus}.
This project focuses on JVM software using Uranus.

Uranus provides an API that instantiates and enters an enclave
when a method annotated as \texttt{@JECall} is called,
and exits the enclave when the method returns or throws.
Furthermore, when a method annotated as \texttt{@JOCall} is called,
the annotated function is executed outside the enclave.

Due to the distinct architecture of JVM applications from native binaries,
corresponding tools for the JVM ecosystem are required for a JVM toolchain.

\subsection{Information Flow Analysis}
Information flow analysis is the analysis of propagation flow between program variables.
In the generic definition, variables are classified into "security levels",
and analysis is performed to validate whether
information flows from a "lower" class to a "higher" class
for a certain ordering of security levels
\cite{SmithGeoffrey2007PoSI}.

In the case of this project, information is partitioned into the classes
"exposable to system" versus "confined within enclave".
Furthermore, as explained in the "Threat model" section below,
certain types of information flow, such as timing leak and other side channels,
are out of scope in this project.
Nevertheless, data-based information flow alone is complex enough to be fully determined.
It is easy to see that certain test cases can only be solved with exponential time algorithms
\cite{SmithGeoffrey2007PoSI}.

\section{Objective}
One problem that arises from the adoption of SGX is
the need to prove that enclave user code does not leak sensitive data.
This project aims to provide a \emph{static analysis} tool for JVM executables
that detects patterns of code violating security policies.

\subsection{User interface}
The analysis tool accepts JVM bytecode (\texttt{*.class}) as input,
allowing usage with any JVM language as source code.

The tool declares two Java annotations:

\begin{lstlisting}[language=Java, caption={@Source and @Sink}, style=j]
@Retention(RetentionPolicy.CLASS)
@Target({
	ElementType.LOCAL_VARIABLE,
	ElementType.PARAMETER,
	ElementType.METHOD,
	ElementType.TYPE,
})
public @interface Source {
	public boolean except();
}

@Retention(RetentionPolicy.CLASS)
@Target({ElementType.LOCAL_VARIABLE, ElementType.PARAMETER})
public @interface Sink {
}
\end{lstlisting}

The meanings of the annotations are explained in the next subsection.

\subsection{Basic algorithm}
Variables annotated as \texttt{@Source},
expressions calling \texttt{@Source} methods
and expressions constructing \texttt{@Source} classes
are identified as sources of sensitive data,
side effects of manipulating which would propagate sensitive data as well.
The flow analysis is terminated
when it is assigned to a \texttt{@Sink} variable (or one of its fields),
or when it is returned in a \texttt{@Source} method,
or when it is thrown in a \texttt{@Source(except = true)} method.
Otherwise, flow reaching non-\texttt{@Source} return points,
\texttt{@JOCall} entry points and assignment to static fields
are flagged as security violations.
Assignments to fields in `this` are allowed
only if the current class is annotated as `@Source`,
in which case use of such fields from the `this` scope are automatically `@Source` as well.

If flow is passed into another concrete Java method,
the corresponding parameter(s) in the called method is implicitly marked with \texttt{@Source}
and the called method (along with all known overrides) will be analyzed recursively as well,
with the exception that returning/throwing sensitive flow
would implicitly mark the method as \texttt{@Source} (and \texttt{except = true} as appropriate)
instead of directly triggering an error condition.
Note that this leads to a violation flag when infinite recursion is detected.
In the case of abstract methods, a contract on the method declaration is required,
but all known subclasses are analyzed as well.

Apparently, the expression assigned into the \texttt{@Source} variable,
as well as the code calling methods with \texttt{@Source} parameters,
also contain sensitive data.
However, it is not necessary to tag everything sensitive as \texttt{@Source} directly,
since this annotation is only used for static analysis.

Note that this structure of analysis is still vulnerable to false positives and false negatives,
since a fully correct analysis is reducible to the halting problem.

\begin{lstlisting}[language=Java, caption=Examples, style=j]
@Source
static int decrypt(
		@Source PrivateKey key,
		byte[] encrypted,
		@Sink byte[] decrypted,
) {
	int length = 0;

	// Propagation: `key` => `new DecryptionStream(key)` => `b`
	// Note that `DecryptionStream` is inferred to be `@Source`
	// if it stores derivatives of `key` in its constructor.
	for(byte b : new DecryptionStream(key)) {
		// Propagation: `b` => `decrypted`
		// This will raise a violation if `decrypted` is not `@Sink`
		decrypted[length] = b;

		// Propagation: `new DecryptionStream(key)` => `length`
		length++;
	}

	// This will raise a violation if the method is not `@Source`
	return length;
}
\end{lstlisting}

\subsection{Threat model}
Although the executable in question is executed within the JVM,
the adversary of concern can be anything that can access process memory directly,
including other threads in the JVM runtime, the JVM runtime itself,
other processes, system kernel, hypervsior and BIOS.
Noting that the JVM runtime
does not possess more privilege over the kernel itself,
and that the JVM runtime can be directly controlled by adversaries from the kernel layer,
the threat model to be assessed is akin to those used in analysis of native executables.
Furthermore, since the subject of analysis is to be executed within Uranus
but this project only analyzes user code but not Uranus code,
it is not meaningful to adopt a threat model that is not a subset of that of Uranus.
In particular, architectural-level side-channel attacks such as timing attacks
are out of scope of this project
(timing attacks exist as a general problem
that is not even specific to TEE security models anyway).
The security model shall focus on attacks based on data flow.

\section{Prior work}
\subsection{Glamdring}
In the sector of native executables,
there exist tools to perform validation or even automation of enclave partitioning.
An example is the Glamdring \cite{glamdring} framework,
which automatically selects an appropriate partition to separate the enclave code in C projects.
It detects the flow of annotated as \texttt{\#pragma glamdring sensitive-source},
ensuring they do not lead to any side effects observable by non-enclaved code
other than those annotated explicitly as \texttt{\#pragma glamdring sensitive-sink}.
It adopts a four-phase approach,
starting from detection of such annotations to mark endpoints of the information flow graph,
then construct a "program dependence graph" (PDG) to search sensitive data-handling code,
then produces "partition specification" to declare partition requirements,
finally using a source-to-source compiler to partition the code into separate
trusted and untrusted code libraries.

Apart from the first three phases,
the others are comparable to the methodology used in this project.
Nevertheless, since this project aims to produce
a \emph{checking} tool instead of a \emph{code generation} tool,
higher tolerance for false positives is preferred
as the user can manually \texttt{@SuppressWarnings} false positives
without the performance tradeoff as would be in Glamdring,
while a low false negative rate increases confidence
in this tool as a cryptographic proof.

\section{Workflow}
\subsection{Required components}
\subsubsection{Flow analysis framework}
A general framework is to be developed as the interface
between the user/toolchain and the security policy implementation.
This component includes the following steps:

\begin{enumerate}
	\item A Gradle task to startup the tool
	\item Loading Java bytecode into an analyzable information flow graph
	\item Abstractions to iterate security policies
\end{enumerate}

\subsubsection{Security policies}
Security policies are the information flow predicates
to determine whether certain constructs violate requirements \cite{sinha2016design}.
Each security policy involves four steps of work:

\begin{enumerate}
	\item Enumerate a test case that leads to security violation
	\item Generalize the test case into a pattern
	\item Implement algorithm to identify this pattern
	\item Perform formal analysis to prove correctness of the algorithm
\end{enumerate}

A number of security policies will be formally derived
and provided in the final report.
Since such implementations are necessarily non-exhaustive,
an analysis of policies not enforced in the project will also be explained.

\subsection{Third party tools and dependencies}
\subsubsection{Deliverables}
The tool will be shipped in the form of a Gradle plugin,
allowing adoption of the analysis task into common toolchains.

\subsubsection{Language}
The project will be completed mostly in Kotlin.
In addition to the strengths of Java,
it provides more concise syntax and improved language design.

\subsubsection{Flow analysis}
A number of information flow analysis frameworks exist in the Java ecosystem.
including JOANA \cite{joana} and JFlow \cite{jflow}.
A comparison on such frameworks will be performed
to adopt into the "flow analysis framework" component.

\subsection{Work Schedule}
\paragraph{Early October} Finalize the selection of third-party frameworks and tools
\paragraph{Mid and Late October} Complete the flow analysis framework
\paragraph{Late October to Late November} Iterations of security policy implementations
\paragraph{Late November} Conclusion and analysis
	of implemented and unimplemented security policies

\addcontentsline{toc}{section}{References}
\bibliographystyle{acm}
\bibliography{cite.bib}{}

\end{document}
