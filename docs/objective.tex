\section{Objectives}\label{sec:objectives}
This section describes the usage and intended behaviour of \pname{}.

\subsection{Marker API}\label{subsec:marker-api}
\IncludeCode{lst:source-sink-def}{./SourceSinkDef.java}
{Definition of \code{sourceMarker} and \code{sinkMarker}}{.55}{3}

The \code{enclavlow-api} Gradle submodule in the project
is a library exposing two identity functions as expression markers
as shown in Listing~\ref{lst:source-sink-def}.
Corresponding definitions such as \code{intSourceMarker}
are also defined for the eight Java primitive types
for both source and sink (omitted in Listing~\ref{lst:source-sink-def} for brevity).
Users can wrap \emph{ultimate} sensitive data sources with \code{sourceMarker}
and mark \emph{intended} leaks with \code{sinkMarker}.

\IncludeCode{lst:catch-wrap-throw}{./catch-wrap-throw.java}
{Catch-wrap-throw construct}{.35}{1}

Exceptions induced inside parameter expression for \code{sinkMarker}
is not considered a sensitive data sink.
This is because throwing sensitive data is a rare use case,
has a wide range of scenarios
and highly depends on the exact class thrown.
If sensitive information in an exception is intended for leaking,
a more verbose catch-wrap-throw syntax can be used
as demonstrated in Listing~\ref{lst:catch-wrap-throw}.
\code{sinkMarker} can also be used to explicitly suppress false positives generated by \pname{}.

\IncludeCode{lst:SourceSinkExample}{./SourceSinkExample.java}
{Simple example of \code{sourceMarker} and \code{sinkMarker}}{.6}{2}

A simple example usage is shown in Listing~\ref{lst:SourceSinkExample}.
In particular, on line 4, \code{raw} is not \code{sourceMarker}
because parsing is a late stage after raw data extraction
and \code{sourceMarker} should only be applied on the ultimate source,
which is asserted on line 5 that \q{computing the sum of \code{raw} is a legitimate leak}.
\code{result} on line 14 is not marked \code{sinkMarker}
because the leak of sensitive information should be analyzed.
\code{sum} on line 22 is not marked \code{sinkMarker}
because it is a sensitivity-neutral utility function
that does not imply any assertion on whether the leak is acceptable;
otherwise incorrect behaviour is created by changing line 12 to Listing~\ref{lst:computeSum},
where \code{parse} no longer returns a security-sensitive value.

\IncludeCode{lst:computeSum}{./computeSum-example-leak.java}
{Example of leak through \code{computeSum}}{.55}{2.5}

\subsection{User interface}\label{subsec:user-interface}
The \code{enclavlow-plugin} Gradle submodule
is a Gradle plugin providing a task \code{:enclavlow},
which depends on the \code{:classes} builtin task
and performs flow analysis on the class binaries.
The analysis report is generated as HTML format at
\code{build/reports/enclavlow/index.html}
relative to the project on which task is invoked.
The report contains the following elements:

\paragraph{Method summary}
Each method defined in the source project (i.e.\ excluding libraries and Java \ac{SDK})
is displayed with sensitive data that have passed through its parameters or return path.
If multiple invocations lead to different data flows,
the union of such data flows is displayed.

\paragraph{Redundant protection}
Methods detected to be run inside enclaves but never involved with any sensitive data
are highlighted in an index called \q{Redundant protection}.
For each highlighted method, the developer
should mark it as \code{@JOCall} to run out of enclaves
or move its \code{@JECall} annotation to appropriate method calls,
or adjust the \code{sourceMarker}/\code{sinkMarker} wrappers.

\paragraph{Data leaks}
Methods which result in immediate data leaks,
such as methods passing security-sensitive data to other \code{@JOCall} methods
or methods marked \code{@JECall} returning/throwing security-sensitive data,
are highlighted in an index called \q{Data leaks}.
For each highlighted method, the developer
should move it into enclave boundaries,
or adjust the \code{sourceMarker}/\code{sinkMarker} wrappers.

\subsection{Threat model}\label{subsec:threat-model}
The adversary of concern has privileged access to the host system,
including other threads in the \ac{JVM} runtime, the \ac{JVM} runtime itself,
other (root) processes, the operating system kernel,
the hypervisor, the BIOS and hardware such as the CPU and the RAM,
with the exception of the \ac{SGX} execution part of the CPU\@.
Note that untrusted hardware cannot execute the enclave code
in the presence of cryptographically provable attestation performed with Uranus~\cite{uranus},
so privileged access to the CPU does not imply privileged access to the \ac{SGX} module.

Since all applications of interest are run on Uranus,
it is not meaningful to analyze threat models more capable than that as assessed by Uranus.
In particular, side channels such as timing attacks are not to be assessed.
\pname{} only studies attacks through at the data layer,
where the adversary has read and write access
to arbitrary data and instruction memory beyond \ac{SGX} enclaves.

There are also some operating system-based exploits already tackled by Uranus.
For example, system calls are intercepted by Uranus with secure mechanisms
to ensure that control flow cannot be known by the system through these calls.
Uranus also provides memory safety checks for object field assignment,
but this check is disabled in this project
since one of the goals is to provide a system that can be used to replace such check.
