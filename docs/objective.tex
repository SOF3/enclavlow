\section{Objectives}
This section describes the usage and precise behaviour of \pname{}.

\subsection{Marker API}
The \code{enclavlow-api} Gradle submodule in the project
is a library exposing two identity functions as expression markers
as shown in Listing \ref{lst:source-sink-def}.
Corresponding definitions such as \code{intSourceMarker}
are also defined for the eight Java primitive types
for both source and sink but omitted here.

\IncludeCode{lst:source-sink-def}{./SourceSinkDef.java}
{Definition of \code{sourceMarker} and \code{sinkMarker}}

Users should wrap \emph{ultimate} data source variables as \code{sourceMarker},
and mark \emph{acceptable} leaks as \code{sinkMarker}.
Note that throwing sensitive data is a rare use case,
has a wide range of scenarios
and highly depends on the exact class thrown.
If an exception is expected to be marked \code{sinkMarker},
the developer should use a more verbose syntax of \code{catch}ing the exception,
wrapping it with \code{sinkMarker} and throwing the wrapped expression as in Listing \ref{lst:catch-wrap-throw}.

\code{sinkMarker} can also be used to explicitly suppress false positives generated by \pname{}.
A simple example usage is shown in Listing \ref{lst:SourceSinkExample}.

\IncludeCode{lst:catch-wrap-throw}{./catch-wrap-throw.java}
{Catch-wrap-throw construct}


\IncludeCode{lst:SourceSinkExample}{./SourceSinkExample.java}
{Simple example of \code{sourceMarker} and \code{sinkMarker}}

Attention to be given to the following points:
\begin{itemize}
	\item On line 4, \code{raw} is \emph{not} \code{sourceMarker}.
		This is because parsing is a late stage after raw data extraction,
		and \code{sourceMarker} should only be applied on the ultimate source.
	\item Line 5 asserts that \q{computing the sum of \code{raw} is a legitimate leak}.
	\item On line 14, \code{result} is not marked \code{sinkMarker},
		because the leak of sensitive information should be analyzed.
	\item On line 22, \code{sum} is not marked \code{sinkMarker}.
		This is because it is a sensitivity-neutral utility function
		that does not imply any assertion on whether the leak is acceptable.
		Otherwise, if line 12 is changed to Listing \ref{lst:computeSum},
		\code{parse} no longer returns a security-sensitive value,
		which is incorrect behaviour.
\end{itemize}

\IncludeCode{lst:computeSum}{./computeSum-example-leak.java}
{Example of leak through computeSum}

\subsection{User interface}
The \code{enclavlow-plugin} Gradle submodule
is a Gradle plugin providing a task \code{:enclavlow},
which depends on the \code{:classes} builtin task
and performs flow analysis on the class binaries.
The analysis report is generated as HTML format at
\code{build/reports/enclavlow/index.html}
relative to the project on which task is invoked.
The report contains the following elements:

\paragraph{Method summary}
Each method defined in the downstream project (i.e. excluding libraries and Java stdlib)
is displayed with sensitive data that have passed through its parameters or return path.
If multiple invokations lead to different data flows,
the union of such data flows is displayed.

\paragraph{Redundant protection}
Methods detected to be run inside enclaves but never involved with any sensitive data
are highlighted in an index called \q{Redundant protection}.
For each highlighted method, the developer
should mark it as \code{@JOCall} to run out of enclaves
or move its \code{@JECall} annotation to appropriate method calls,
or adjust the \code{sourceMarker}/\code{sinkMarker} wrappers.

\paragraph{Data leaks}
Methods which result in immediate data leaks,
such as methods passing security-sensitive data to other \code{@JOCall} methods
or methods marked \code{@JECall} returning/throwing security-sensitive data,
are highlighted in an index called \q{Data leaks}.
For each highlighted method, the developer
should move it into enclave boundaries,
or adjust the \code{sourceMarker}/\code{sinkMarker} wrappers.

\subsection{Threat model}
The adversary of concern has privileged access to the host system,
including other threads in the JVM runtime, the JVM runtime itself,
other (root) processes, the operating system kernel,
the hypervisor, the BIOS and hardware such as the CPU and the RAM,
with the exception of the SGX execution part of the CPU.
Note that untrusted hardware cannot execute the enclave code
in the presence of cryptographically provable attestation performed with Uranus,
\cite{uranus},
so privileged access to the CPU does not imply privileged access to the SGX module.

Since all applications of interest are run on Uranus,
it is not meaningful to analyze threat models more capable than that as assessed by Uranus.
In particular, side channels such as timing attacks are not to be assessed.
\pname{} only studies attacks through at the data layer,
where the adversary has read and write access
to arbitrary data and instruction memory beyond SGX enclaves.
