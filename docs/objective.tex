\section{Objectives}
This section describes the usage and precise behaviour of \pname{}.

\subsection{Annotation API}
The \code{enclavlow-api} Gradle submodule in the project
is a \code{compileOnly} library exposing two annotations:

\IncludeCode{lst:source-sink-def}{./SourceSinkDef.java}
{Definition of \code{@Source} and \code{@Sink}}

Users should mark \emph{ultimate} data source variables as \code{@Source},
and mark \emph{acceptable} leaks as \code{@Sink}.
The \code{@Sink} annotation, when applied on methods,
is merely a shortcut to assign return values to a \code{@Sink} variables first.
Such shortcut does not apply for throw expressions,
because throwing sensitive data is a rare use case,
has a wide range of scenarios
and highly depends on the exact class thrown.
Genuine throw sinks should use a more verbose syntax of \code{catch}ing the exception,
assigning to a local \code{@Sink} variable and throwing the local variable.

\code{@Sink} can also be used to explicitly suppress false positives generated by \pname{}.

A simple example usage is as below:

\IncludeCode{lst:SourceSinkExample}{./SourceSinkExample.java}
{Simple example of \code{@Source} and \code{@Sink}}

Attention to be given to the following points:
\begin{itemize}
	\item On line 4, \code{raw} is \emph{not} marked \code{@Source}.
		This is because parsing is a late stage after raw data extraction,
		and \code{@Source} should only be applied on the ultimate source.
	\item Line 5 and line 2 altogether assert that
		\q{computing the sum of \code{raw} is a legitimate leak}.
	\item On line 8, \code{parse} is not marked \code{@Sink},
		because the leak of sensitive information should be analyzed.
	\item On line 17, \code{computeSum} is not marked \code{@Sink}.
		This is because it is a sensitivity-neutral utility function
		that does not imply any assertion on whether the leak is acceptable.
		Otherwise, if line 12 is changed to Listing \ref{lst:computeSum},
		\code{parse} no longer returns a security-sensitive value,
		which is incorrect behaviour.
\end{itemize}

\begin{lstlisting}[style=j, language=java, label={lst:computeSum},
caption={Example of leak through computeSum}]
	result.add(computeSum(Collections.singletonList((int) i)));
\end{lstlisting}

\subsection{User interface}
The \code{enclavlow-plugin} Gradle submodule
is a Gradle plugin providing a task \code{:enclavlow},
which depends on the \code{:classes} builtin task
and performs flow analysis on the class binaries.
The analysis report is generated as HTML format at
\code{build/reports/enclavlow/index.html}
relative to the project on which task is invoked.
The report contains the following elements:

\paragraph{Method summary}
Each method defined in the downstream project (i.e. excluding libraries and Java stdlib)
is displayed with sensitive data that have passed through its parameters or return path.
If multiple invokations lead to different data flows,
the union of such data flows is displayed.

\paragraph{Redundant protection}
Methods detected to be run inside enclaves but never involved with any sensitive data
are highlighted in an index called \q{Redundant protection}.
For each highlighted method, the developer
should mark it as \code{@JOCall} to run out of enclaves
or move its \code{@JECall} annotation to appropriate method calls,
or adjust the \code{@Source}/\code{@Sink} annotations.

\paragraph{Data leaks}
Methods which result in immediate data leaks,
such as methods passing security-sensitive data to other \code{@JOCall} methods
or methods marked \code{@JECall} returning/throwing security-sensitive data,
are highlighted in an index called \q{Data leaks}.
For each highlighted method, the developer
should move it into enclave boundaries,
or adjust the \code{@Source}/\code{@Sink} annotations.

\subsection{Threat model}
The adversary of concern has privileged access to the host system,
including other threads in the JVM runtime, the JVM runtime itself,
other (root) processes, the operating system kernel,
the hypervisor, the BIOS and hardware such as the CPU and the RAM,
with the exception of the SGX execution part of the CPU.
Note that untrusted hardware cannot execute the enclave code
in the presence of cryptographically provable attestation performed with Uranus,
\cite{uranus},
so privileged access to the CPU does not imply privileged access to the SGX module.

Since all applications of interest are run on Uranus,
it is not meaningful to analyze threat models more capable than that as assessed by Uranus.
In particular, side channels such as timing attacks are not to be assessed.
\pname{} only studies attacks through at the data layer,
where the adversary has read and write access
to arbitrary data and instruction memory beyond SGX enclaves.
