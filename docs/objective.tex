\section{Objectives}\label{sec:objectives}
This section describes the usage and intended behaviour of \pname{}.

\subsection{Marker API}\label{subsec:marker-api}
The \code{enclavlow-api} Gradle submodule in the project
is a library exposing two identity functions as expression markers
as shown in Listing~\ref{lst:source-sink-def}.
Corresponding definitions such as \code{intSourceMarker}
are also defined for the eight Java primitive types
for both source and sink (omitted in Listing~\ref{lst:source-sink-def} for brevity).
Users can wrap \emph{ultimate} sensitive data sources with \code{sourceMarker}
and mark \emph{intended} leaks with \code{sinkMarker}.
It is expected that the identity wrapper function is optimized away by \ac{JIT}.

\IncludeCode{lst:source-sink-def}{./SourceSinkDef.java}
{Definition of \code{sourceMarker} and \code{sinkMarker}}{.55}{3}

Exceptions induced from the expression of parameters to \code{sinkMarker}
are not collected by the sink.
This is because throwing sensitive data is a rare use case,
has a wide range of scenarios
and highly depends on the exact class thrown.
If sensitive information in an exception is intended for leaking,
a more verbose catch-wrap-throw syntax can be used
as demonstrated in Listing~\ref{lst:catch-wrap-throw}.
\code{sinkMarker} can also be used to explicitly suppress false positives generated by \pname{}.

\IncludeCode{lst:catch-wrap-throw}{./catch-wrap-throw.java}
{Catch-wrap-throw construct}{.35}{1}

A simple example usage is shown in Listing~\ref{lst:SourceSinkExample}.
In particular:
\begin{itemize}
  \item On line 4, \code{raw} is not \code{sourceMarker}
    because parsing is a late stage after raw data extraction
    and \code{sourceMarker} should only be applied on the ultimate source,
    which is asserted on line 5 that \q{computing the sum of \code{raw} is a legitimate leak}.
  \item \code{result} on line 14 is not marked \code{sinkMarker}
    because the leak of sensitive information should be analyzed.
    \code{sum} on line 22 is not marked \code{sinkMarker}
    because it is a sensitivity-neutral utility function
    that does not imply any assertion on whether the leak is acceptable;
    otherwise incorrect behaviour is created by changing line 12 to Listing~\ref{lst:computeSum},
    where \code{parse} no longer returns a security-sensitive value.
\end{itemize}

\IncludeCode{lst:SourceSinkExample}{./SourceSinkExample.java}
{Simple example of \code{sourceMarker} and \code{sinkMarker}}{.6}{2}

\IncludeCode{lst:computeSum}{./computeSum-example-leak.java}
{Example of leak through \code{computeSum}}{.55}{2.5}

\subsection{User interface}\label{subsec:user-interface}
The \code{enclavlow-plugin} Gradle submodule
is a Gradle plugin providing a task \code{:enclavlow},
which depends on the \code{:classes} builtin task
and performs flow analysis on the class binaries.
The analysis report is generated as HTML format in the Gradle reports directory
(build/reports/enclavlow.html).
The report contains the following elements:

\paragraph{Flow summary}
Each method through which sensitive data flow is reported.
If multiple invocations lead to different data flows,
the union of such data flows is displayed.

\paragraph{Data leaks}
Code that which results in immediate data leaks,
such as methods passing security-sensitive data to other \code{@JOCall} methods
or methods marked \code{@JECall} returning/throwing security-sensitive data,
are highlighted in an index called \q{Sensitive leaks}.
For each highlighted method, the developer
should move it into enclave boundaries,
or adjust the \code{sourceMarker}/\code{sinkMarker} wrappers.

\paragraph{Contract graphs}
The contract graph of each method is provided as hyperlinks in the HTML report
and can be viewed using the Graphviz Online tool \cite{dreampuf}.

When debug mode is enabled, the \ac{LFG} (see section \ref{subsubsec:lfg})
of each method can also be viewed in DOT/SVG format from \code{lfgOutput}
under the Gradle build directory.

\subsection{Threat model}\label{subsec:threat-model}
The adversary of concern is expected privileged access to the host system,
including other threads in the \ac{JVM} runtime, the \ac{JVM} runtime itself,
other (root) processes, the operating system kernel,
the hypervisor and the BIOS.
The adversary cannot access the \ac{SGX} execution part of the CPU
as cryptographically provable by SGX attestation mechanism.
While the realistic adversary also has access to hardware resources
such as system clock and temperature sensor modules,
which can be used to implement side-channel attacks,
analyzing such side channels involves
system-, environment-~and architecture-dependent analysis.
As these side channels rarely expose meaningful and specific information,
they are beyond the scope of this project.

The security model provided by Uranus is also slightly altered.
Uranus rejects assignment to objects outside enclaves
to mitigate some attacks like the Iago attack.
On the other hand, \pname{} considers such writes to be rvalue-leaking and control-flow-leaking,
but still assumes them permissible.
This change intends to target future changes in Uranus
that perform compile-time flow analysis.
