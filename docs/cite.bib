@inproceedings{glamdring,
  title={Glamdring: Automatic application partitioning for intel $\{$SGX$\}$},
  author={Lind, Joshua and Priebe, Christian and Muthukumaran, Divya and O'Keeffe, Dan and Aublin, Pierre-Louis and Kelbert, Florian and Reiher, Tobias and Goltzsche, David and Eyers, David and Kapitza, R{\"u}diger and others},
  booktitle={2017 $\{$USENIX$\}$ Annual Technical Conference ($\{$USENIX$\}$$\{$ATC$\}$ 17)},
  pages={285--298},
  year={2017}
}
@article{sinha2016design,
  title={A design and verification methodology for secure isolated regions},
  author={Sinha, Rohit and Costa, Manuel and Lal, Akash and Lopes, Nuno P and Rajamani, Sriram and Seshia, Sanjit A and Vaswani, Kapil},
  journal={ACM SIGPLAN Notices},
  volume={51},
  number={6},
  pages={665--681},
  year={2016},
  publisher={ACM New York, NY, USA}
}
@inproceedings{schuster2015vc3,
  title={VC3: Trustworthy data analytics in the cloud using SGX},
  author={Schuster, Felix and Costa, Manuel and Fournet, C{\'e}dric and Gkantsidis, Christos and Peinado, Marcus and Mainar-Ruiz, Gloria and Russinovich, Mark},
  booktitle={2015 IEEE Symposium on Security and Privacy},
  pages={38--54},
  year={2015},
  organization={IEEE}
}
@inproceedings{uranus,
  title={Uranus: Simple, efficient sgx programming and its applications [UNPUBLISHED]},
  author={Jiang, XC Jianyu and Tzs, CW and Li, On and Shen, T and Zhao, S},
  booktitle={Proceedings of the 15th ACM ASIA Conference on Computer and Communications Security (ASIACCS ‘20)},
  year={2020}
}
@misc{azure,
	title={Microsoft Azure},
	howpublished = "\url{https://azure.microsoft.com/en-us/}",
}
@misc{aws,
	title={Amazon Web Services},
	howpublished = "\url{https://aws.amazon.com}",
}
@misc{ReadProcessMemory,
	title={ReadProcessMemory function (memoryapi.h), Microsoft Docs},
	howpublished = "\url{https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-readprocessmemory}",
}
@manual{linuxprocmem,
	title = "proc(5) Linux User's Manual, /proc/[pid]/mem",
	year = "2020",
	month = "August",
}
@article{AtamliReinehAhmad2017Affa,
issn = {1532-0626},
abstract = {Summary
The size and complexity of modern applications are the underlying causes of numerous security vulnerabilities. In order to mitigate the risks arising from such vulnerabilities, various techniques have been proposed to isolate the execution of sensitive code from the rest of the application and from other software on the platform (such as the operating system). New technologies, notably Intel's Software Guard Extensions (SGX), are becoming available to enhance the security of partitioned applications. SGX provides a trusted execution environment (TEE), called an enclave, that protects the integrity of the code and the confidentiality of the data inside it from other software, including the operating system (OS). However, even with these partitioning techniques, it is not immediately clear exactly how they can and should be used to partition applications. How should a particular application be partitioned? How many TEEs should be used? What granularity of partitioning should be applied? To some extent, this is dependent on the capabilities and performance of the partitioning technology in use. However, as partitioning becomes increasingly common, there is a need for systematisation in the design of partitioning schemes.
To address this need, we present a novel framework consisting of four overarching types of partitioning schemes through which applications can make use of TEEs. These schemes range from coarse‐grained partitioning, in which the whole application is included in a single TEE, through to ultra‐fine partitioning, in which each piece of security‐sensitive code and data is protected in an individual TEE. Although partitioning schemes themselves are application specific, we establish application‐independent relationships between the types we have defined. Because these relationships have an impact on both the security and performance of the partitioning scheme, we envisage that our framework can be used by software architects to guide the design of application partitioning schemes. To demonstrate the applicability of our framework, we have carried out case studies on two widely used software packages, the Apache Web server and the OpenSSL library. In each case study, we provide four high‐level partitioning schemes—one for each of the types in our framework. We also systematically review the related work on hardware‐enforced partitioning by categorising previous research efforts according to our framework. Copyright © 2017 John Wiley \& Sons, Ltd.},
journal = {Concurrency and computation},
pages = {e4130--n/a},
volume = {29},
publisher = {Wiley Subscription Services, Inc},
number = {23},
year = {2017},
title = {A framework for application partitioning using trusted execution environments},
copyright = {Copyright © 2017 John Wiley \& Sons, Ltd.},
language = {eng},
author = {Atamli‐Reineh, Ahmad and Paverd, Andrew and Petracca, Giuseppe and Martin, Andrew},
keywords = {hardware security ; software vulnerabilities ; SGX ; trusted execution environment},
}
@inproceedings{McKeenFrank2013Iias,
series = {HASP '13},
abstract = {For years the PC community has struggled to provide secure solutions on open platforms. Intel has developed innovative new technology to enable SW developers to develop and deploy secure applications on open platforms. The technology enables applications to execute with confidentiality and integrity in the native OS environment. It does this by providing ISA extensions for generating hardware enforceable containers at a granularity determined by the developer. These containers while opaque to the operating system are managed by the OS. This paper analyzes the threats and attacks to applications. It then describes the ISA extension for generating a HW based container. Finally it describes the programming model of this container.},
pages = {1--1},
publisher = {ACM},
isbn = {1450321186},
year = {2013},
title = {Innovative instructions and software model for isolated execution},
language = {eng},
author = {McKeen, Frank and Alexandrovich, Ilya and Berenzon, Alex and Rozas, Carlos and Shafi, Hisham and Shanbhogue, Vedvyas and Savagaonkar, Uday},
}
@misc{apachehadoop,
	title={Apache Hadoop},
	howpublished = "\url{https://hadoop.apache.org}",
}
@misc{apachespark,
	title={Apache Spark},
	howpublished = "\url{https://spark.apache.org}",
}
@misc{joana,
	title={JOANA (Java Object-sensitive ANAlysis)},
	howpublished = "\url{https://pp.ipd.kit.edu/projects/joana/}",
}
@inproceedings{jflow,
  title={JFlow: Practical mostly-static information flow control},
  author={Myers, Andrew C},
  booktitle={Proceedings of the 26th ACM SIGPLAN-SIGACT symposium on Principles of programming languages},
  pages={228--241},
  year={1999}
}
@incollection{SmithGeoffrey2007PoSI,
series = {Advances in Information Security},
abstract = {In today’s world of the Internet, the World-Wide Web, and Google, information is more accessible than ever before. An unfortunate corollary is that it is harder than ever to protect the privacy of sensitive information. In this chapter, we explore a technique called secure information flow analysis.},
pages = {291--307},
volume = {27},
publisher = {Springer US},
booktitle = {Malware Detection},
isbn = {9780387327204},
year = {2007},
title = {Principles of Secure Information Flow Analysis},
copyright = {Springer Science+Business Media, LLC. 2007},
language = {eng},
address = {Boston, MA},
author = {Smith, Geoffrey},
keywords = {Data Structures, Cryptology and Information Theory ; Computer Systems Organization and Communication Networks ; Data Encryption ; Data Structures ; Computer Science ; Coding and Information Theory ; Computer Communication Networks},
}
@inproceedings {244028,
author = {Chia-che Tsai and Jeongseok Son and Bhushan Jain and John McAvey and Raluca Ada Popa and Donald E. Porter},
title = {Civet: An Efficient Java Partitioning Framework for Hardware Enclaves},
booktitle = {29th {USENIX} Security Symposium ({USENIX} Security 20)},
year = {2020},
isbn = {978-1-939133-17-5},
pages = {505--522},
url = {https://www.usenix.org/conference/usenixsecurity20/presentation/tsai},
publisher = {{USENIX} Association},
month = aug,
}
@inproceedings{GoguenJA1982SPaS,
	issn = {1540-7993},
	abstract = {We assune that the reader is familiar with the ubiquity of information in the modern world and is sympathetic with the need for restricting rights to read, add, modify, or delete information in specific contexts. This need is particularly acute for systems having computers as significant components.},
	pages = {11--11},
	publisher = {IEEE},
	isbn = {9780818604102},
	year = {1982},
	title = {Security Policies and Security Models},
	language = {eng},
	author = {Goguen, J. A and Meseguer, J},
	keywords = {Computers ; Computational modeling ; Automata ; Data models ; Finite element methods ; Mathematical model ; Message systems},
}
@article{SheDongdong2019NEDT,
	abstract = {Dynamic taint analysis (DTA) is widely used by various applications to track
		information flow during runtime execution. Existing DTA techniques use
			rule-based taint-propagation, which is neither accurate (i.e., high false
					positive) nor efficient (i.e., large runtime overhead). It is hard to specify
			taint rules for each operation while covering all corner cases correctly.
			Moreover, the overtaint and undertaint errors can accumulate during the
			propagation of taint information across multiple operations. Finally,
		rule-based propagation requires each operation to be inspected before applying
			the appropriate rules resulting in prohibitive performance overhead on large
			real-world applications.
			In this work, we propose NEUTAINT, a novel end-to-end approach to track
			information flow using neural program embeddings. The neural program embeddings
			model the target's programs computations taking place between taint sources and
			sinks, which automatically learns the information flow by observing a diverse
			set of execution traces. To perform lightweight and precise information flow
			analysis, we utilize saliency maps to reason about most influential sources for
			different sinks. NEUTAINT constructs two saliency maps, a popular machine
			learning approach to influence analysis, to summarize both coarse-grained and
			fine-grained information flow in the neural program embeddings.
			We compare NEUTAINT with 3 state-of-the-art dynamic taint analysis tools. The
			evaluation results show that NEUTAINT can achieve 68\% accuracy, on average,
		which is 10\% improvement while reducing 40 times runtime overhead over the
			second-best taint tool Libdft on 6 real world programs. NEUTAINT also achieves
			61\% more edge coverage when used for taint-guided fuzzing indicating the
			effectiveness of the identified influential bytes.},
	year = {2019},
	title = {Neutaint: Efficient Dynamic Taint Analysis with Neural Networks},
	copyright = {http://arxiv.org/licenses/nonexclusive-distrib/1.0},
	language = {eng},
	author = {She, Dongdong and Chen, Yizheng and Shah, Abhishek and Ray, Baishakhi and Jana, Suman},
	keywords = {Computer Science - Cryptography and Security},
}
@inproceedings{BellJonathan2014Pidd,
series = {OOPSLA '14},
abstract = {Dynamic taint analysis is a well-known information flow analysis problem with many possible applications. Taint tracking allows for analysis of application data flow by assigning labels to data, and then propagating those labels through data flow. Taint tracking systems traditionally compromise among performance, precision, soundness, and portability. Performance can be critical, as these systems are often intended to be deployed to production environments, and hence must have low overhead. To be deployed in security-conscious settings, taint tracking must also be sound and precise. Dynamic taint tracking must be portable in order to be easily deployed and adopted for real world purposes, without requiring recompilation of the operating system or language interpreter, and without requiring access to application source code.
We present Phosphor , a dynamic taint tracking system for the Java Virtual Machine (JVM) that simultaneously achieves our goals of performance, soundness, precision, and portability. Moreover, to our knowledge, it is the first portable general purpose taint tracking system for the JVM. We evaluated Phosphor 's performance on two commonly used JVM languages (Java and Scala), on two successive revisions of two commonly used JVMs (Oracle's HotSpot and OpenJDK's IcedTea) and on Android's Dalvik Virtual Machine, finding its performance to be impressive: as low as 3% (53% on average; 220% at worst) using the DaCapo macro benchmark suite. This paper describes our approach toward achieving portable taint tracking in the JVM.},
pages = {83--101},
publisher = {ACM},
isbn = {1450325858},
year = {2014},
title = {Phosphor: illuminating dynamic data flow in commodity jvms},
language = {eng},
author = {Bell, Jonathan and Kaiser, Gail},
keywords = {taint tracking ; dataflow analysis},
}

