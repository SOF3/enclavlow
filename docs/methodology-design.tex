\subsection{Design}\label{subsec:design}
Since the adversary has arbitrary access to any untrusted memory and instruction,
the security policies of \pname{} differ slightly from typical information flow analysis.
For instance, the statement \code{a.b.c = d;} usually
does not propagte the effect of \code{d} to \code{a},
but since the adversary is capable of changing \code{b} to any memory location of its favour,
the security of this statement depends on whether \code{a} is trusted.

\pname{} adopts a flow graph approach,
where each node represents an element that may be leaked.

\begin{defin}
	Given a flow graph $(V, E)$, for all $x, y \in V$,
	$(x, y) \in E$ if and only if
	allocating $y$ outside an enclave reduces the indistinguishability of $x$.
\end{defin}

Note that this definition (\q{our definition}) differs slightly from
the usual definition of flow graphs (especially in \ac{DTA}),
where an edge $(x, y)$ represents the flow of information from $x$ to $y$~\cite{YinHeng2007Pcsi}.
In the usual definition, only adversary read access to $y$ is concerned,
while in our definition, the adversary possesses write access to $x$.

\subsubsection{\acf{CFG}}
\pname{} adopts an approach where a \ac{CFG} is constructed for each method analyzed.
The \ac{CFG} contains the nodes listed in Table \ref{tab:cfg-nodes}.

\begin{table}
	\caption{Nodes in \ac{CFG}}
	\centering
	\begin{tabular}{|c|c|}
		\hline
		Static & Represents data located in static class fields \\ \hline
		This & Represents the object on which a method was invoked \\ \hline
		Param $x$ & Each parameter is represented by a node \\ \hline
		Return & Represents data flow through the return path \\ \hline
		Throw & Represents data flow through the return path \\ \hline
		Source & Represents variables in the method explicitly wrapped in \code{sourceMarker} \\ \hline
		Sink & Represents locals in the method explicitly declared as \code{sinkMarker} \\ \hline
		Control & This is a special node representing how many times the function is called. \\ \hline
		This & \q{Param $y$}, \q{Return}, \q{Throw} and \q{Control}
		from each function called from the current node \\ \hline
	\end{tabular}
	\label{tab:cfg-nodes}
\end{table}

After all methods in a class are evaluated,
the CFGs of child methods called from the analyzed methods
are lazily evaluated as well.
All CFGs are merged into an \ac{AFG},
joined using the function call nodes.

For the case of \ac{OOP} polymorphism,
call graph analysis is performed to identify
the exact subclasses that could be passed.
In case multiple subclasses are possible,
their contract graphs are merged by taking the union of all flow edges.

See Figure~\ref{fig:SourceSinkContract} for an example of \ac{AFG}.
Unconnected nodes are omitted for brevity.

\begin{figure}
	\caption{Example \ac{CFG} for Listing~\ref{lst:SourceSinkExample}}
	\begin{center}
		\digraph[scale=0.5]{contract}{
			rankdir = "LR";
			getSumParam0[label = "getSum\noexpand\n param \#0"];
			getSumControl[label = "getSum\noexpand\n control"];
			parseParam0[label = "parse\noexpand\n param \#0"];
			parseReturn[label = "parse\noexpand\n return"];
			parseControl[label = "parse\noexpand\n control"];
			computeSumParam0[label = "computeSum\noexpand\n param \#0"];
			computeSumReturn[label = "computeSum\noexpand\n return"];
			computeSumControl[label = "computeSum\noexpand\n control"];
			Source -> parseReturn [color = "red"];
			parseReturn -> computeSumParam0 [color = "red"];
			computeSumParam0 -> computeSumReturn [color = "red"];
			computeSumReturn -> Sink [color = "red"];
			getSumParam0 -> parseParam0;
			parseParam0 -> parseReturn;
			parseControl -> parseReturn;
			computeSumControl -> computeSumReturn;
			getSumControl -> parseControl;
			getSumControl -> computeSumControl;
			}
	\end{center}
	\label{fig:SourceSinkContract}
\end{figure}

\subsubsection{\acf{LFG}}
To construct the \ac{CFG},
a local graph is constructed.
The analysis follows along the control flow of the program,
performing the \emph{consume}, \emph{branch} and \emph{merge} operations.

The \ac{LFG} extends the \ac{CFG} with the following additions:
\begin{itemize}
	\item Each local variable (some may exist as intermediate values in source code)
		is allocated a node.
	\item Each branch has its own \q{control} node.
\end{itemize}

The \emph{consume} operation consumes statements in form of \acf{3AC}~\cite{sootsurvivor}.
Every step adds or removes some flow edges,
as described exhaustively in Table~\ref{tab:tac}.
The relationship between the graph and the \q{lvalue}s and \q{rvalue}s
mentioned in Table~\ref{tab:tac} are explained in Table~\ref{tab:lrvalue}.

The \emph{branch} operation performs a deep clone of the \ac{LFG}
and continues following each branch with its clone.

The \emph{merge} operation pops the uppermost control flow node from the graph,
and takes the union of all flows from each branched graph.

The control flow stack is always pushed from a conditional instruction
before splitting into branches,
which is important for attacks that count the number of times a method was called,
hence inferring the sensitive value that determined the branch halting problem.

\begin{table}
	\caption{\ac{3AC} instructions affecting \ac{LFG}}
	\centering
	\begin{tabular}{|c|l|}
		\hline
		\textbf{Instruction type} & \textbf{Effects on \ac{LFG}}
		\\ \hline
		\multirow4*{Assignment} & \q{Control} flows to lvalue nodes of destination. \\
		& Erases current connections to lvalue nodes of destination. \\
		& rvalue nodes of source flow to lvalue nodes of destination. \\
		& lvalue nodes of source flow to rvalue nodes of destination.
		\\ \hline
		\multirow2*{Return} & \q{Control} flows to \q{Return} node. \\
		& rvalue nodes of returned value flow to \q{Return} node.
		\\ \hline
		\multirow2*{Throw} & \q{Control} flows to \q{Throw} node. \\
		& rvalue nodes of thrown value leaks to \q{Throw} node.
		\\ \hline
		\multirow3*{Conditional (If/Switch)}
		& A new \q{Control} node is pushed to the control stack. \\
		& Previous \q{Control} flows to the new \q{Control}. \\
		& rvalue nodes of predicate leaks to the new \q{Control}.
		\\ \hline
		Method call & Same effect as assigning call result to a sink variable.
		\\ \hline
	\end{tabular}
	\label{tab:tac}
\end{table}

\begin{table}
	\caption{lvalue and rvalue nodes for expressions}
	\centering
	\begin{tabular}{|c|c|c|}
		\hline
		\textbf{Expression type} & \textbf{lvalue nodes} & \textbf{rvalue nodes}
		\\ \hline
		Binary operations & unreachable & union of rvalues from operands
		\\ \hline
		Array literal \code{new int[a]} & unreachable
		& union of rvalues from count or literal elements
		\\ \hline
		Array access \code{a[b]} & lvalues of \code a & rvalues of \code a and \code b
		\\ \hline
		Instance field access \code{a.b} & lvalues of \code a & rvalues of \code a
		\\ \hline
		Static field access \code{Class.field} & \q{Static} & none
		\\ \hline
		Parameter & the parameter node \footnotemark{} & the parameter node
		\\ \hline
		Local variable & its own dedicated node & its own dedicated node
		\\ \hline
		\code{this} & \q{This} & \q{This}
		\\ \hline
		Class cast and instanceof & lvalues of the underlying value & rvalues of the underlying value
		\\ \hline
		Method/constructor call & \q{Return} of the called method & \q{Return} of the called method
		\\ \hline
	\end{tabular}
	\label{tab:lrvalue}
\end{table}

\footnotetext{Jimple always first assigns parameters to a local variable,
so direct assignments to the parameter variable will not overwrite it}

In traditional information flow analysis,
this naive approach described in the table appears to result in high false positive rate
as it does not separate the internal structure used by instance fields and arrays.
For example, consider Listing~\ref{lst:iago-attack}
(Jimple code in Listing~\ref{lst:iago-attack-jimple}).
At return point, the \ac{LFG} becomes as shown in Figure~\ref{fig:tfp-graph}.
Intuitively, this appears incorrect;
param \#0 does not flow to \code{return}
since it is just used for \code{this.bar} but not \code{this.qux}.
Nevertheless, in the threat model where
the adversary has access to modify any memory allocated outside the enclave,
such a program is vulnerable to Iago attacks~\cite{iago},
where assignment to object fields may not always work as intended;
if the \code{IagoAttack} context was allocated outside the enclave,
\code{this.bar} might be modified by the adversary to \code{this.qux}
(even if they belong to different classes),
hence leaking into the return value.
Recall the definition of an edge in the \ac{LFG} used in this project,
where $a \to b$ implies $b$ must to be protected if $a$ is protected.

\begin{figure}
	\caption{\ac{LFG} of \code{IagoAttack.foo(int)} in Listing~\ref{lst:iago-attack}}
	\begin{center}
		\digraph[scale=0.5]{local}{
			rankdir = "LR";
			param0 [label = "Param \#0"];
			This -> r0 [dir = "both"];
			param0 -> i0;
			r0 -> r1 [dir = "both"];
			i0 -> r1;
			r0 -> r2 [dir = "both"];
			r2 -> Return;
		}
	\end{center}
	\label{fig:tfp-graph}
\end{figure}

\IncludeCode{lst:iago-attack}{./IagoAttack.java}
{Iago attack}

\IncludeCode{lst:iago-attack-jimple}
{./sootOutput/IagoAttack.jimple}
{Iago attack (Jimple output)}
