\section{Results and Discussion}\label{sec:results-and-discussion}

\subsection{Difficulties and Limitations}\label{subsec:difficulties-and-limitations}
\IncludeCode{lst:oop-subst-attack}{./OopSubstAttack.java}
{Example attack through OOP substitution}{.6}{2.5}

The principles of \ac{OOP} imply that a method called may be swapped with another subclass
that performs different actions than the current one.
Although Uranus prevents the adversary
from passing arbitrary malicious code into the enclave memory,
it is still possible to pass objects of unexpected subclass
through the \code{@JEcall} boundary.
Consider Listing~\ref{lst:oop-subst-attack} for example.
If \code{cs} is passed with a \code{substr} implementation
that writes its parameters to a static variable,
the function would leak the length of the security-sensitive secret,
which is not desirable.
To correctly solve the vulnerability of \ac{OOP} substitution,
it is necessary to perform call graph analysis on the actual classes passed to the method,
which involves more complex framework level work.

\IncludeCode{lst:known-false-positives}{./KnownFalsePositives.java}
{Known false positives}{.6}{3}

Despite optimizations and simplifications,
it is still not possible to perform 100\% accurate information flow analysis
within efficient time complexity~\cite{SmithGeoffrey2007PoSI}.
For example, this project merges conditional branches together
by taking the union of flow graphs,
resulting in easy false positive rates.
Listing~\ref{lst:known-false-positives} is an example of this,
where 

It is also impossible to analyze further than the \ac{JNI} level,
since analyzing across \ac{JNI} boundary implies
the need to interact with a native analysis tool.
Since this involves multiple layers of interaction
such as native code reverse engineering (hence legal issues)
and platform-specific support (defeating the purpose of using \ac{JVM}),
Since Uranus effectively denies system calls,
the contract is always assumed to be
$\left\{ (p, \text{return}) : p \in \text{params} \right\}$.
This signature might miss some special cases,
such as the \code{System.arraycopy} method in the Java \ac{SDK},
which leaks information about its bounds parameters to an array.

For the sake of consistency with Uranus,
it was originally intended to expose \code{sourceMarker} and \code{sinkMarker}
as annotations on local variables instead of method calls.
However, \ac{JLS} 9.6.1.2 explicitly stated that
\q{an annotation on a local variable declaration
is never retained in the binary representation}~\cite{jls},
so a method call based approach is used instead.

\subsection{Recommended future research}\label{subsec:recommended-future-research}
There are multiple areas in which this project can be extended.

\pname{} applies handwritten heuristics to identify leaks.
Some special edges, such as field projection, are not very well-defined.
This reduces the reliability of \pname{} in terms of robustness in targeted attacks,
which is an important feature for security analysis.
A formal proof through tools like Coq~\cite{coq}
can be utilized to ensure that the \ac{LFG} construction does not miss marginal cases.

The project can also be used to improve Uranus performance.
Currently, to ensure enclave confidentiality,
Uranus requires enclave code accessing untrusted memory to
use Uranus's untrusted-memory \ac{API}
like \code{SafeGetField} and \code{SafeWriteField}\cite{uranus},
which checks the memory address against enclave bounds at runtime.
The static analysis in \pname{} allows Uranus to validate these bounds at compile time,

